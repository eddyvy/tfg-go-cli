package {{.Table.Name}}

import "{{.ProjectConfig.Base}}{{.ProjectConfig.Name}}/internal/database"

func findAll() ([]*Model, error) {
	sqlStr := `SELECT * FROM {{.Table.Name}}`
	rows, err := database.DB.Query(sqlStr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	{{.Table.Name}}s := make([]*Model, 0)
	for rows.Next() {
		{{.Table.Name}} := new(Model)
		err := rows.Scan(&{{.Table.Name}}.Id, &{{.Table.Name}}.Name, &{{.Table.Name}}.Age, &{{.Table.Name}}.Country)
		if err != nil {
			return nil, err
		}
		{{.Table.Name}}s = append({{.Table.Name}}s, {{.Table.Name}})
	}

	return {{.Table.Name}}s, nil
}

func findOne(id int) (*Model, error) {
	sqlStr := `SELECT * FROM {{.Table.Name}} WHERE id = $1`

	{{.Table.Name}} := new(Model)
	row := database.DB.QueryRow(sqlStr, id)
	err := row.Scan(&{{.Table.Name}}.Id, &{{.Table.Name}}.Name, &{{.Table.Name}}.Age, &{{.Table.Name}}.Country)

	if err != nil {
		return nil, err
	}

	return {{.Table.Name}}, nil
}

func create({{.Table.Name}} *Input) (*Model, error) {
	sqlStr := `INSERT INTO {{.Table.Name}} (name, age, country) VALUES ($1, $2, $3) RETURNING id`

	var id int

	err := database.DB.QueryRow(sqlStr, {{.Table.Name}}.Name, {{.Table.Name}}.Age, {{.Table.Name}}.Country).Scan(&id)
	if err != nil {
		return nil, err
	}

	return &Model{
		Id:      id,
		Name:    {{.Table.Name}}.Name,
		Age:     {{.Table.Name}}.Age,
		Country: {{.Table.Name}}.Country}, nil
}

func update(id int, {{.Table.Name}} *Input) (*Model, error) {
	sqlStr := `UPDATE {{.Table.Name}} SET name = $1, age = $2, country = $3 WHERE id = $4`

	_, err := database.DB.Exec(sqlStr, {{.Table.Name}}.Name, {{.Table.Name}}.Age, {{.Table.Name}}.Country, id)
	if err != nil {
		return nil, err
	}

	return &Model{
		Id:      id,
		Name:    {{.Table.Name}}.Name,
		Age:     {{.Table.Name}}.Age,
		Country: {{.Table.Name}}.Country}, nil
}

func delete(id int) error {
	sqlStr := `DELETE FROM {{.Table.Name}} WHERE id = $1`

	_, err := database.DB.Exec(sqlStr, id)
	if err != nil {
		return err
	}

	return nil
}
